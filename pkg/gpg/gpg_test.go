/*
Copyright Â© 2025 Gonzalo Alvarez

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package gpg

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGenerateGPGConf(t *testing.T) {
	conf := generateGPGConf()

	requiredSettings := []string{
		"use-agent",
		"no-emit-version",
		"no-comments",
		"keyid-format 0xlong",
		"with-fingerprint",
		"list-options show-uid-validity",
		"verify-options show-uid-validity",
	}

	for _, setting := range requiredSettings {
		if !strings.Contains(conf, setting) {
			t.Errorf("expected gpg.conf to contain %q", setting)
		}
	}
}

func TestGenerateAgentConf(t *testing.T) {
	pinentryPath := "/usr/bin/pinentry-mac"
	conf := generateAgentConf(pinentryPath)

	if !strings.Contains(conf, "pinentry-program /usr/bin/pinentry-mac") {
		t.Errorf("expected agent conf to contain pinentry path")
	}

	if !strings.Contains(conf, "default-cache-ttl 600") {
		t.Errorf("expected agent conf to contain default-cache-ttl")
	}

	if !strings.Contains(conf, "max-cache-ttl 7200") {
		t.Errorf("expected agent conf to contain max-cache-ttl")
	}

	if !strings.Contains(conf, "# GPG Agent Config generated by kepr") {
		t.Errorf("expected agent conf to contain header comment")
	}
}

func TestGenerateAgentConf_DifferentPaths(t *testing.T) {
	tests := []struct {
		name         string
		pinentryPath string
	}{
		{"mac", "/opt/homebrew/bin/pinentry-mac"},
		{"gnome", "/usr/bin/pinentry-gnome3"},
		{"curses", "/usr/bin/pinentry-curses"},
		{"default", "/usr/bin/pinentry"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			conf := generateAgentConf(tt.pinentryPath)
			expected := "pinentry-program " + tt.pinentryPath
			if !strings.Contains(conf, expected) {
				t.Errorf("expected conf to contain %q, got:\n%s", expected, conf)
			}
		})
	}
}

func TestWriteConfigs(t *testing.T) {
	tempDir := t.TempDir()

	gpg := &GPG{
		HomeDir:            tempDir,
		ConfigPath:         filepath.Join(tempDir, "gpg.conf"),
		AgentConfigPath:    filepath.Join(tempDir, "gpg-agent.conf"),
		SCDaemonConfigPath: filepath.Join(tempDir, "scdaemon.conf"),
		PinentryPath:       "/usr/bin/pinentry-test",
		io:                 NewMockIO(),
	}

	err := gpg.WriteConfigs()
	if err != nil {
		t.Fatalf("WriteConfigs() failed: %v", err)
	}

	gpgConfData, err := os.ReadFile(gpg.ConfigPath)
	if err != nil {
		t.Fatalf("failed to read gpg.conf: %v", err)
	}

	gpgConf := string(gpgConfData)
	if !strings.Contains(gpgConf, "use-agent") {
		t.Error("gpg.conf missing 'use-agent'")
	}
	if !strings.Contains(gpgConf, "keyid-format 0xlong") {
		t.Error("gpg.conf missing 'keyid-format 0xlong'")
	}

	agentConfData, err := os.ReadFile(gpg.AgentConfigPath)
	if err != nil {
		t.Fatalf("failed to read gpg-agent.conf: %v", err)
	}

	agentConf := string(agentConfData)
	if !strings.Contains(agentConf, "pinentry-program /usr/bin/pinentry-test") {
		t.Error("gpg-agent.conf missing correct pinentry-program")
	}
}

func TestWriteConfigs_FilePermissions(t *testing.T) {
	tempDir := t.TempDir()

	gpg := &GPG{
		HomeDir:            tempDir,
		ConfigPath:         filepath.Join(tempDir, "gpg.conf"),
		AgentConfigPath:    filepath.Join(tempDir, "gpg-agent.conf"),
		SCDaemonConfigPath: filepath.Join(tempDir, "scdaemon.conf"),
		PinentryPath:       "/usr/bin/pinentry",
		io:                 NewMockIO(),
	}

	err := gpg.WriteConfigs()
	if err != nil {
		t.Fatalf("WriteConfigs() failed: %v", err)
	}

	gpgConfInfo, err := os.Stat(gpg.ConfigPath)
	if err != nil {
		t.Fatalf("failed to stat gpg.conf: %v", err)
	}

	expectedMode := os.FileMode(0600)
	if gpgConfInfo.Mode().Perm() != expectedMode {
		t.Errorf("gpg.conf permissions: expected %o, got %o", expectedMode, gpgConfInfo.Mode().Perm())
	}

	agentConfInfo, err := os.Stat(gpg.AgentConfigPath)
	if err != nil {
		t.Fatalf("failed to stat gpg-agent.conf: %v", err)
	}

	if agentConfInfo.Mode().Perm() != expectedMode {
		t.Errorf("gpg-agent.conf permissions: expected %o, got %o", expectedMode, agentConfInfo.Mode().Perm())
	}
}

func TestWriteConfigs_InvalidPath(t *testing.T) {
	gpg := &GPG{
		HomeDir:         "/nonexistent/path/that/does/not/exist",
		ConfigPath:      "/nonexistent/path/that/does/not/exist/gpg.conf",
		AgentConfigPath: "/nonexistent/path/that/does/not/exist/gpg-agent.conf",
		PinentryPath:    "/usr/bin/pinentry",
		io:              NewMockIO(),
	}

	err := gpg.WriteConfigs()
	if err == nil {
		t.Fatal("expected WriteConfigs() to fail with invalid path, got nil")
	}
}

func TestGenerateKeys_Success(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234:\nuid:-::::::::Test User <test@example.com>:\n", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", "ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234", "cv25519", "encr", "0"}, "", "", nil)

	gpg := &GPG{
		BinaryPath:   "/usr/bin/gpg",
		HomeDir:      tempDir,
		PinentryPath: "/usr/bin/pinentry",
		executor:     mockExec,
		io:           NewMockIO(),
	}

	fingerprint, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err != nil {
		t.Fatalf("GenerateKeys() failed: %v", err)
	}

	expected := "ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234"
	if fingerprint != expected {
		t.Errorf("expected fingerprint %q, got %q", expected, fingerprint)
	}

	if len(mockExec.Calls) != 3 {
		t.Errorf("expected 3 calls, got %d", len(mockExec.Calls))
	}

	if !mockExec.WasCalled("/usr/bin/gpg", "--batch", "--gen-key") {
		t.Error("expected gen-key command to be called")
	}

	if !mockExec.WasCalled("/usr/bin/gpg", "--list-keys", "--with-colons") {
		t.Error("expected list-keys command to be called")
	}
}

func TestGenerateKeys_MasterKeyFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"},
		"", "gpg: error generating key", fmt.Errorf("exit status 2"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err == nil {
		t.Fatal("expected GenerateKeys() to fail, got nil")
	}

	if !strings.Contains(err.Error(), "failed to generate master key") {
		t.Errorf("expected error to mention master key generation, got: %v", err)
	}
}

func TestGenerateKeys_SubkeyFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::TESTFINGERPRINT123456789012345678:\nuid:-::::::::Test User <test@example.com>:\n", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", "TESTFINGERPRINT123456789012345678", "cv25519", "encr", "0"},
		"", "gpg: error adding subkey", fmt.Errorf("exit status 2"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err == nil {
		t.Fatal("expected GenerateKeys() to fail on subkey, got nil")
	}

	if !strings.Contains(err.Error(), "failed to generate encryption subkey") {
		t.Errorf("expected error to mention subkey generation, got: %v", err)
	}
}

func TestGenerateKeys_FingerprintRetrievalFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"", "gpg: no keys", fmt.Errorf("exit status 2"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err == nil {
		t.Fatal("expected GenerateKeys() to fail on fingerprint retrieval, got nil")
	}

	if !strings.Contains(err.Error(), "failed to list keys") {
		t.Errorf("expected error to mention list keys failure, got: %v", err)
	}
}

func TestGenerateKeys_WithSpecialCharactersInName(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::SPECIALCHARSFINGERPRINT12345678901234:\nuid:-::::::::Test User (Comment) <test+tag@example.com>:\n", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", "SPECIALCHARSFINGERPRINT12345678901234", "cv25519", "encr", "0"}, "", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	fingerprint, err := gpg.GenerateKeys("Test User (Comment) <tag>", "test+tag@example.com")
	if err != nil {
		t.Fatalf("GenerateKeys() with special characters failed: %v", err)
	}

	expected := "SPECIALCHARSFINGERPRINT12345678901234"
	if fingerprint != expected {
		t.Errorf("expected fingerprint %q, got %q", expected, fingerprint)
	}

	if len(mockExec.Calls) != 3 {
		t.Errorf("expected 3 calls, got %d", len(mockExec.Calls))
	}

	firstCall := mockExec.Calls[0]
	if !strings.Contains(firstCall.Stdin, "Test User (Comment) <tag>") {
		t.Error("expected name with special characters in key template")
	}
	if !strings.Contains(firstCall.Stdin, "test+tag@example.com") {
		t.Error("expected email with + character in key template")
	}
}

func TestMockExecutor_UnexpectedCommand(t *testing.T) {
	mockExec := NewMockExecutor()

	err := mockExec.Command("/usr/bin/gpg", "--unexpected", "--command").Run()
	if err == nil {
		t.Fatal("expected mock executor to fail on unexpected command, got nil")
	}

	if !strings.Contains(err.Error(), "mock: unexpected command") {
		t.Errorf("expected error to mention unexpected command, got: %v", err)
	}
}

func TestMockExecutor_WasCalled(t *testing.T) {
	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys"}, "output", "", nil)

	mockExec.Command("/usr/bin/gpg", "--list-keys").Run()

	if !mockExec.WasCalled("/usr/bin/gpg", "--list-keys") {
		t.Error("expected WasCalled to return true for executed command")
	}

	if mockExec.WasCalled("/usr/bin/gpg", "--other-command") {
		t.Error("expected WasCalled to return false for non-executed command")
	}
}

func TestMockExecutor_MultipleCallsSameCommand(t *testing.T) {
	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys"}, "output1", "", nil)

	mockExec.Command("/usr/bin/gpg", "--list-keys").Run()
	mockExec.Command("/usr/bin/gpg", "--list-keys").Run()

	if len(mockExec.Calls) != 2 {
		t.Errorf("expected 2 calls recorded, got %d", len(mockExec.Calls))
	}
}

func TestGenerateSCDaemonConf(t *testing.T) {
	conf := generateSCDaemonConf()

	requiredSettings := []string{
		"disable-ccid",
		"pcsc-shared",
		"card-timeout 5",
	}

	for _, setting := range requiredSettings {
		if !strings.Contains(conf, setting) {
			t.Errorf("expected scdaemon.conf to contain %q", setting)
		}
	}
}

func TestListPublicKeys_Success(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::FINGERPRINT1234567890123456789012345678:\nuid:-::::::::Test User <test@example.com>:\nfpr:::::::::FINGERPRINT9876543210987654321098765432:\nuid:-::::::::Other User <other@example.com>:\n", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	keys, err := gpg.ListPublicKeys()
	if err != nil {
		t.Fatalf("ListPublicKeys() failed: %v", err)
	}

	if len(keys) != 2 {
		t.Errorf("expected 2 keys, got %d", len(keys))
	}

	if keys[0].Fingerprint != "FINGERPRINT1234567890123456789012345678" {
		t.Errorf("expected fingerprint FINGERPRINT1234567890123456789012345678, got %s", keys[0].Fingerprint)
	}

	if keys[0].Email != "test@example.com" {
		t.Errorf("expected email test@example.com, got %s", keys[0].Email)
	}

	if keys[0].Name != "Test User" {
		t.Errorf("expected name Test User, got %s", keys[0].Name)
	}
}

func TestListPublicKeys_Empty(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"}, "", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	keys, err := gpg.ListPublicKeys()
	if err != nil {
		t.Fatalf("ListPublicKeys() failed: %v", err)
	}

	if len(keys) != 0 {
		t.Errorf("expected 0 keys, got %d", len(keys))
	}
}

func TestListPublicKeys_Error(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"", "error", fmt.Errorf("gpg error"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.ListPublicKeys()
	if err == nil {
		t.Fatal("expected ListPublicKeys() to fail")
	}
}

func TestBackupMasterKey_Cancelled(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--armor", "--export-secret-key", "FINGERPRINT123"},
		"-----BEGIN PGP PRIVATE KEY BLOCK-----\nkey content\n-----END PGP PRIVATE KEY BLOCK-----\n", "", nil)

	mockIO := NewMockIO()
	mockIO.ConfirmResult = false

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         mockIO,
	}

	err := gpg.BackupMasterKey("FINGERPRINT123")
	if err == nil {
		t.Fatal("expected BackupMasterKey() to fail when cancelled")
	}

	if !strings.Contains(err.Error(), "cancelled by user") {
		t.Errorf("expected error about cancellation, got: %v", err)
	}
}

func TestBackupMasterKey_EmptyKey(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--armor", "--export-secret-key", "FINGERPRINT123"},
		"", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	err := gpg.BackupMasterKey("FINGERPRINT123")
	if err == nil {
		t.Fatal("expected BackupMasterKey() to fail with empty key")
	}

	if !strings.Contains(err.Error(), "empty") {
		t.Errorf("expected error about empty key, got: %v", err)
	}
}

func TestBackupMasterKey_ExportFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--armor", "--export-secret-key", "FINGERPRINT123"},
		"", "export error", fmt.Errorf("gpg error"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	err := gpg.BackupMasterKey("FINGERPRINT123")
	if err == nil {
		t.Fatal("expected BackupMasterKey() to fail on export error")
	}

	if !strings.Contains(err.Error(), "failed to export") {
		t.Errorf("expected error about export failure, got: %v", err)
	}
}

func TestBackupMasterKey_Success(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--armor", "--export-secret-key", "FINGERPRINT123"},
		"-----BEGIN PGP PRIVATE KEY BLOCK-----\nkey content\n-----END PGP PRIVATE KEY BLOCK-----\n", "", nil)

	mockIO := NewMockIO()
	mockIO.ConfirmResult = true

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         mockIO,
	}

	err := gpg.BackupMasterKey("FINGERPRINT123")
	if err != nil {
		t.Fatalf("BackupMasterKey() failed: %v", err)
	}
}

func TestGenerateKeys_NoKeysAfterGeneration(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"}, "", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.GenerateKeys("Test", "test@example.com")
	if err == nil {
		t.Fatal("expected GenerateKeys() to fail when no keys found after generation")
	}

	if !strings.Contains(err.Error(), "no keys found after generation") {
		t.Errorf("expected error about no keys found, got: %v", err)
	}
}

func TestGPGKey_Struct(t *testing.T) {
	key := GPGKey{
		Fingerprint: "ABC123",
		UserID:      "Test User <test@example.com>",
		Email:       "test@example.com",
		Name:        "Test User",
	}

	if key.Fingerprint != "ABC123" {
		t.Errorf("Fingerprint = %q, want ABC123", key.Fingerprint)
	}
	if key.Email != "test@example.com" {
		t.Errorf("Email = %q, want test@example.com", key.Email)
	}
	if key.Name != "Test User" {
		t.Errorf("Name = %q, want Test User", key.Name)
	}
}

func TestExportPublicKey_Success(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--armor", "--export", "FINGERPRINT123"},
		"-----BEGIN PGP PUBLIC KEY BLOCK-----\npublic key content\n-----END PGP PUBLIC KEY BLOCK-----\n", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	keyData, err := gpg.ExportPublicKey("FINGERPRINT123")
	if err != nil {
		t.Fatalf("ExportPublicKey() failed: %v", err)
	}

	if !strings.Contains(string(keyData), "BEGIN PGP PUBLIC KEY BLOCK") {
		t.Errorf("expected PGP public key block, got: %s", string(keyData))
	}
}

func TestExportPublicKey_Empty(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--armor", "--export", "UNKNOWN"},
		"", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.ExportPublicKey("UNKNOWN")
	if err == nil {
		t.Fatal("expected ExportPublicKey() to fail with empty result")
	}

	if !strings.Contains(err.Error(), "empty") {
		t.Errorf("expected error about empty key, got: %v", err)
	}
}

func TestExportPublicKey_Error(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--armor", "--export", "FINGERPRINT123"},
		"", "gpg error", fmt.Errorf("gpg error"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.ExportPublicKey("FINGERPRINT123")
	if err == nil {
		t.Fatal("expected ExportPublicKey() to fail")
	}

	if !strings.Contains(err.Error(), "failed to export public key") {
		t.Errorf("expected error about export failure, got: %v", err)
	}
}

func TestImportPublicKey_Success(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--import"}, "", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	err := gpg.ImportPublicKey([]byte("-----BEGIN PGP PUBLIC KEY BLOCK-----\nkey\n-----END PGP PUBLIC KEY BLOCK-----\n"))
	if err != nil {
		t.Fatalf("ImportPublicKey() failed: %v", err)
	}

	if !mockExec.WasCalled("/usr/bin/gpg", "--import") {
		t.Error("expected import command to be called")
	}
}

func TestImportPublicKey_Error(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--import"},
		"", "import error", fmt.Errorf("gpg error"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	err := gpg.ImportPublicKey([]byte("bad key data"))
	if err == nil {
		t.Fatal("expected ImportPublicKey() to fail")
	}

	if !strings.Contains(err.Error(), "failed to import public key") {
		t.Errorf("expected error about import failure, got: %v", err)
	}
}

func TestMockExecutor_LookPath(t *testing.T) {
	mockExec := NewMockExecutor()

	path, err := mockExec.LookPath("gpg")
	if err != nil {
		t.Fatalf("LookPath() failed: %v", err)
	}

	if path != "/usr/bin/gpg" {
		t.Errorf("LookPath(gpg) = %q, want /usr/bin/gpg", path)
	}
}

func TestMockExecutor_LookPathWithResponse(t *testing.T) {
	mockExec := NewMockExecutor()
	mockExec.AddLookPathResponse("pinentry-mac", "/opt/homebrew/bin/pinentry-mac", nil)

	path, err := mockExec.LookPath("pinentry-mac")
	if err != nil {
		t.Fatalf("LookPath() failed: %v", err)
	}

	if path != "/opt/homebrew/bin/pinentry-mac" {
		t.Errorf("LookPath(pinentry-mac) = %q, want /opt/homebrew/bin/pinentry-mac", path)
	}
}

func TestMockExecutor_LookPathError(t *testing.T) {
	mockExec := NewMockExecutor()
	mockExec.AddLookPathResponse("notfound", "", fmt.Errorf("not found"))

	_, err := mockExec.LookPath("notfound")
	if err == nil {
		t.Error("expected LookPath() to fail")
	}
}

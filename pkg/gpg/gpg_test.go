/*
Copyright Â© 2025 Gonzalo Alvarez

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package gpg

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGenerateGPGConf(t *testing.T) {
	conf := generateGPGConf()

	requiredSettings := []string{
		"use-agent",
		"no-emit-version",
		"no-comments",
		"keyid-format 0xlong",
		"with-fingerprint",
		"list-options show-uid-validity",
		"verify-options show-uid-validity",
	}

	for _, setting := range requiredSettings {
		if !strings.Contains(conf, setting) {
			t.Errorf("expected gpg.conf to contain %q", setting)
		}
	}
}

func TestGenerateAgentConf(t *testing.T) {
	pinentryPath := "/usr/bin/pinentry-mac"
	conf := generateAgentConf(pinentryPath)

	if !strings.Contains(conf, "pinentry-program /usr/bin/pinentry-mac") {
		t.Errorf("expected agent conf to contain pinentry path")
	}

	if !strings.Contains(conf, "default-cache-ttl 600") {
		t.Errorf("expected agent conf to contain default-cache-ttl")
	}

	if !strings.Contains(conf, "max-cache-ttl 7200") {
		t.Errorf("expected agent conf to contain max-cache-ttl")
	}

	if !strings.Contains(conf, "# GPG Agent Config generated by kepr") {
		t.Errorf("expected agent conf to contain header comment")
	}
}

func TestGenerateAgentConf_DifferentPaths(t *testing.T) {
	tests := []struct {
		name         string
		pinentryPath string
	}{
		{"mac", "/opt/homebrew/bin/pinentry-mac"},
		{"gnome", "/usr/bin/pinentry-gnome3"},
		{"curses", "/usr/bin/pinentry-curses"},
		{"default", "/usr/bin/pinentry"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			conf := generateAgentConf(tt.pinentryPath)
			expected := "pinentry-program " + tt.pinentryPath
			if !strings.Contains(conf, expected) {
				t.Errorf("expected conf to contain %q, got:\n%s", expected, conf)
			}
		})
	}
}

func TestWriteConfigs(t *testing.T) {
	tempDir := t.TempDir()

	gpg := &GPG{
		HomeDir:            tempDir,
		ConfigPath:         filepath.Join(tempDir, "gpg.conf"),
		AgentConfigPath:    filepath.Join(tempDir, "gpg-agent.conf"),
		SCDaemonConfigPath: filepath.Join(tempDir, "scdaemon.conf"),
		PinentryPath:       "/usr/bin/pinentry-test",
		io:                 NewMockIO(),
	}

	err := gpg.WriteConfigs()
	if err != nil {
		t.Fatalf("WriteConfigs() failed: %v", err)
	}

	gpgConfData, err := os.ReadFile(gpg.ConfigPath)
	if err != nil {
		t.Fatalf("failed to read gpg.conf: %v", err)
	}

	gpgConf := string(gpgConfData)
	if !strings.Contains(gpgConf, "use-agent") {
		t.Error("gpg.conf missing 'use-agent'")
	}
	if !strings.Contains(gpgConf, "keyid-format 0xlong") {
		t.Error("gpg.conf missing 'keyid-format 0xlong'")
	}

	agentConfData, err := os.ReadFile(gpg.AgentConfigPath)
	if err != nil {
		t.Fatalf("failed to read gpg-agent.conf: %v", err)
	}

	agentConf := string(agentConfData)
	if !strings.Contains(agentConf, "pinentry-program /usr/bin/pinentry-test") {
		t.Error("gpg-agent.conf missing correct pinentry-program")
	}
}

func TestWriteConfigs_FilePermissions(t *testing.T) {
	tempDir := t.TempDir()

	gpg := &GPG{
		HomeDir:            tempDir,
		ConfigPath:         filepath.Join(tempDir, "gpg.conf"),
		AgentConfigPath:    filepath.Join(tempDir, "gpg-agent.conf"),
		SCDaemonConfigPath: filepath.Join(tempDir, "scdaemon.conf"),
		PinentryPath:       "/usr/bin/pinentry",
		io:                 NewMockIO(),
	}

	err := gpg.WriteConfigs()
	if err != nil {
		t.Fatalf("WriteConfigs() failed: %v", err)
	}

	gpgConfInfo, err := os.Stat(gpg.ConfigPath)
	if err != nil {
		t.Fatalf("failed to stat gpg.conf: %v", err)
	}

	expectedMode := os.FileMode(0600)
	if gpgConfInfo.Mode().Perm() != expectedMode {
		t.Errorf("gpg.conf permissions: expected %o, got %o", expectedMode, gpgConfInfo.Mode().Perm())
	}

	agentConfInfo, err := os.Stat(gpg.AgentConfigPath)
	if err != nil {
		t.Fatalf("failed to stat gpg-agent.conf: %v", err)
	}

	if agentConfInfo.Mode().Perm() != expectedMode {
		t.Errorf("gpg-agent.conf permissions: expected %o, got %o", expectedMode, agentConfInfo.Mode().Perm())
	}
}

func TestWriteConfigs_InvalidPath(t *testing.T) {
	gpg := &GPG{
		HomeDir:         "/nonexistent/path/that/does/not/exist",
		ConfigPath:      "/nonexistent/path/that/does/not/exist/gpg.conf",
		AgentConfigPath: "/nonexistent/path/that/does/not/exist/gpg-agent.conf",
		PinentryPath:    "/usr/bin/pinentry",
		io:              NewMockIO(),
	}

	err := gpg.WriteConfigs()
	if err == nil {
		t.Fatal("expected WriteConfigs() to fail with invalid path, got nil")
	}
}

func TestGenerateKeys_Success(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234:\nuid:-::::::::Test User <test@example.com>:\n", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", "ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234", "cv25519", "encr", "0"}, "", "", nil)

	gpg := &GPG{
		BinaryPath:   "/usr/bin/gpg",
		HomeDir:      tempDir,
		PinentryPath: "/usr/bin/pinentry",
		executor:     mockExec,
		io:           NewMockIO(),
	}

	fingerprint, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err != nil {
		t.Fatalf("GenerateKeys() failed: %v", err)
	}

	expected := "ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234"
	if fingerprint != expected {
		t.Errorf("expected fingerprint %q, got %q", expected, fingerprint)
	}

	if len(mockExec.Calls) != 3 {
		t.Errorf("expected 3 calls, got %d", len(mockExec.Calls))
	}

	if !mockExec.WasCalled("/usr/bin/gpg", "--batch", "--gen-key") {
		t.Error("expected gen-key command to be called")
	}

	if !mockExec.WasCalled("/usr/bin/gpg", "--list-keys", "--with-colons") {
		t.Error("expected list-keys command to be called")
	}
}

func TestGenerateKeys_MasterKeyFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"},
		"", "gpg: error generating key", fmt.Errorf("exit status 2"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err == nil {
		t.Fatal("expected GenerateKeys() to fail, got nil")
	}

	if !strings.Contains(err.Error(), "failed to generate master key") {
		t.Errorf("expected error to mention master key generation, got: %v", err)
	}
}

func TestGenerateKeys_SubkeyFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::TESTFINGERPRINT123456789012345678:\nuid:-::::::::Test User <test@example.com>:\n", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", "TESTFINGERPRINT123456789012345678", "cv25519", "encr", "0"},
		"", "gpg: error adding subkey", fmt.Errorf("exit status 2"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err == nil {
		t.Fatal("expected GenerateKeys() to fail on subkey, got nil")
	}

	if !strings.Contains(err.Error(), "failed to generate encryption subkey") {
		t.Errorf("expected error to mention subkey generation, got: %v", err)
	}
}

func TestGenerateKeys_FingerprintRetrievalFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"", "gpg: no keys", fmt.Errorf("exit status 2"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	_, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err == nil {
		t.Fatal("expected GenerateKeys() to fail on fingerprint retrieval, got nil")
	}

	if !strings.Contains(err.Error(), "failed to list keys") {
		t.Errorf("expected error to mention list keys failure, got: %v", err)
	}
}

func TestGenerateKeys_WithSpecialCharactersInName(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::SPECIALCHARSFINGERPRINT12345678901234:\nuid:-::::::::Test User (Comment) <test+tag@example.com>:\n", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", "SPECIALCHARSFINGERPRINT12345678901234", "cv25519", "encr", "0"}, "", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
		io:         NewMockIO(),
	}

	fingerprint, err := gpg.GenerateKeys("Test User (Comment) <tag>", "test+tag@example.com")
	if err != nil {
		t.Fatalf("GenerateKeys() with special characters failed: %v", err)
	}

	expected := "SPECIALCHARSFINGERPRINT12345678901234"
	if fingerprint != expected {
		t.Errorf("expected fingerprint %q, got %q", expected, fingerprint)
	}

	if len(mockExec.Calls) != 3 {
		t.Errorf("expected 3 calls, got %d", len(mockExec.Calls))
	}

	firstCall := mockExec.Calls[0]
	if !strings.Contains(firstCall.Stdin, "Test User (Comment) <tag>") {
		t.Error("expected name with special characters in key template")
	}
	if !strings.Contains(firstCall.Stdin, "test+tag@example.com") {
		t.Error("expected email with + character in key template")
	}
}

func TestMockExecutor_UnexpectedCommand(t *testing.T) {
	mockExec := NewMockExecutor()

	err := mockExec.Command("/usr/bin/gpg", "--unexpected", "--command").Run()
	if err == nil {
		t.Fatal("expected mock executor to fail on unexpected command, got nil")
	}

	if !strings.Contains(err.Error(), "mock: unexpected command") {
		t.Errorf("expected error to mention unexpected command, got: %v", err)
	}
}

func TestMockExecutor_WasCalled(t *testing.T) {
	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys"}, "output", "", nil)

	mockExec.Command("/usr/bin/gpg", "--list-keys").Run()

	if !mockExec.WasCalled("/usr/bin/gpg", "--list-keys") {
		t.Error("expected WasCalled to return true for executed command")
	}

	if mockExec.WasCalled("/usr/bin/gpg", "--other-command") {
		t.Error("expected WasCalled to return false for non-executed command")
	}
}

func TestMockExecutor_MultipleCallsSameCommand(t *testing.T) {
	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys"}, "output1", "", nil)

	mockExec.Command("/usr/bin/gpg", "--list-keys").Run()
	mockExec.Command("/usr/bin/gpg", "--list-keys").Run()

	if len(mockExec.Calls) != 2 {
		t.Errorf("expected 2 calls recorded, got %d", len(mockExec.Calls))
	}
}

/*
Copyright Â© 2025 Gonzalo Alvarez

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package gpg

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestParseFingerprintFromGPGOutput_Success(t *testing.T) {
	output := `tru::1:1733100896:0:3:1:5
pub:-:255:22:4B4040BF3305A8FF:1733100896:::-:::escaESCA:::::::23::0:
fpr:::::::::4AE0C21F0B01B9EC08E48D3C4B4040BF3305A8FF:
uid:-::::1733100896::C8F9E7F8D8A9E8F8D8A9E8F8::Test User <test@example.com>::::::::::0:
sub:-:255:18:A399C16AA20E1EC7:1733100896::::::e:::::::23::0:
fpr:::::::::9E8F9E8F9E8F9E8FA399C16AA20E1EC7:`

	fingerprint, err := parseFingerprintFromGPGOutput(output)
	if err != nil {
		t.Fatalf("expected no error, got: %v", err)
	}

	expected := "4AE0C21F0B01B9EC08E48D3C4B4040BF3305A8FF"
	if fingerprint != expected {
		t.Errorf("expected fingerprint %q, got %q", expected, fingerprint)
	}
}

func TestParseFingerprintFromGPGOutput_MultipleKeys(t *testing.T) {
	output := `pub:-:255:22:AAAAAAAAAAAAAAAA:1733100896:::-:::escaESCA:::::::23::0:
fpr:::::::::AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA:
uid:-::::1733100896::C8F9E7F8D8A9E8F8D8A9E8F8::First Key <first@example.com>::::::::::0:
pub:-:255:22:BBBBBBBBBBBBBBBB:1733100897:::-:::escaESCA:::::::23::0:
fpr:::::::::BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB:
uid:-::::1733100897::C8F9E7F8D8A9E8F8D8A9E8F8::Second Key <second@example.com>::::::::::0:`

	fingerprint, err := parseFingerprintFromGPGOutput(output)
	if err != nil {
		t.Fatalf("expected no error, got: %v", err)
	}

	expected := "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
	if fingerprint != expected {
		t.Errorf("expected first fingerprint %q, got %q", expected, fingerprint)
	}
}

func TestParseFingerprintFromGPGOutput_NoFingerprint(t *testing.T) {
	output := `pub:-:255:22:4B4040BF3305A8FF:1733100896:::-:::escaESCA:::::::23::0:
uid:-::::1733100896::C8F9E7F8D8A9E8F8D8A9E8F8::Test User <test@example.com>::::::::::0:`

	_, err := parseFingerprintFromGPGOutput(output)
	if err == nil {
		t.Fatal("expected error for missing fingerprint, got nil")
	}

	expectedError := "fingerprint not found in gpg output"
	if err.Error() != expectedError {
		t.Errorf("expected error %q, got %q", expectedError, err.Error())
	}
}

func TestParseFingerprintFromGPGOutput_EmptyOutput(t *testing.T) {
	output := ""

	_, err := parseFingerprintFromGPGOutput(output)
	if err == nil {
		t.Fatal("expected error for empty output, got nil")
	}
}

func TestParseFingerprintFromGPGOutput_MalformedFprLine(t *testing.T) {
	output := `pub:-:255:22:4B4040BF3305A8FF:1733100896:::-:::escaESCA:::::::23::0:
fpr:too:few:fields
uid:-::::1733100896::C8F9E7F8D8A9E8F8D8A9E8F8::Test User <test@example.com>::::::::::0:`

	_, err := parseFingerprintFromGPGOutput(output)
	if err == nil {
		t.Fatal("expected error for malformed fpr line, got nil")
	}
}

func TestParseFingerprintFromGPGOutput_WithWhitespace(t *testing.T) {
	output := `
	
pub:-:255:22:4B4040BF3305A8FF:1733100896:::-:::escaESCA:::::::23::0:
fpr:::::::::4AE0C21F0B01B9EC08E48D3C4B4040BF3305A8FF:

uid:-::::1733100896::C8F9E7F8D8A9E8F8D8A9E8F8::Test User <test@example.com>::::::::::0:
	`

	fingerprint, err := parseFingerprintFromGPGOutput(output)
	if err != nil {
		t.Fatalf("expected no error, got: %v", err)
	}

	expected := "4AE0C21F0B01B9EC08E48D3C4B4040BF3305A8FF"
	if fingerprint != expected {
		t.Errorf("expected fingerprint %q, got %q", expected, fingerprint)
	}
}

func TestGenerateGPGConf(t *testing.T) {
	conf := generateGPGConf()

	requiredSettings := []string{
		"use-agent",
		"no-emit-version",
		"no-comments",
		"keyid-format 0xlong",
		"with-fingerprint",
		"list-options show-uid-validity",
		"verify-options show-uid-validity",
	}

	for _, setting := range requiredSettings {
		if !strings.Contains(conf, setting) {
			t.Errorf("expected gpg.conf to contain %q", setting)
		}
	}
}

func TestGenerateAgentConf(t *testing.T) {
	pinentryPath := "/usr/bin/pinentry-mac"
	conf := generateAgentConf(pinentryPath)

	if !strings.Contains(conf, "pinentry-program /usr/bin/pinentry-mac") {
		t.Errorf("expected agent conf to contain pinentry path")
	}

	if !strings.Contains(conf, "default-cache-ttl 600") {
		t.Errorf("expected agent conf to contain default-cache-ttl")
	}

	if !strings.Contains(conf, "max-cache-ttl 7200") {
		t.Errorf("expected agent conf to contain max-cache-ttl")
	}

	if !strings.Contains(conf, "# GPG Agent Config generated by kepr") {
		t.Errorf("expected agent conf to contain header comment")
	}
}

func TestGenerateAgentConf_DifferentPaths(t *testing.T) {
	tests := []struct {
		name         string
		pinentryPath string
	}{
		{"mac", "/opt/homebrew/bin/pinentry-mac"},
		{"gnome", "/usr/bin/pinentry-gnome3"},
		{"curses", "/usr/bin/pinentry-curses"},
		{"default", "/usr/bin/pinentry"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			conf := generateAgentConf(tt.pinentryPath)
			expected := "pinentry-program " + tt.pinentryPath
			if !strings.Contains(conf, expected) {
				t.Errorf("expected conf to contain %q, got:\n%s", expected, conf)
			}
		})
	}
}

func TestWriteConfigs(t *testing.T) {
	tempDir := t.TempDir()

	gpg := &GPG{
		HomeDir:         tempDir,
		ConfigPath:      filepath.Join(tempDir, "gpg.conf"),
		AgentConfigPath: filepath.Join(tempDir, "gpg-agent.conf"),
		PinentryPath:    "/usr/bin/pinentry-test",
	}

	err := gpg.writeConfigs()
	if err != nil {
		t.Fatalf("writeConfigs() failed: %v", err)
	}

	gpgConfData, err := os.ReadFile(gpg.ConfigPath)
	if err != nil {
		t.Fatalf("failed to read gpg.conf: %v", err)
	}

	gpgConf := string(gpgConfData)
	if !strings.Contains(gpgConf, "use-agent") {
		t.Error("gpg.conf missing 'use-agent'")
	}
	if !strings.Contains(gpgConf, "keyid-format 0xlong") {
		t.Error("gpg.conf missing 'keyid-format 0xlong'")
	}

	agentConfData, err := os.ReadFile(gpg.AgentConfigPath)
	if err != nil {
		t.Fatalf("failed to read gpg-agent.conf: %v", err)
	}

	agentConf := string(agentConfData)
	if !strings.Contains(agentConf, "pinentry-program /usr/bin/pinentry-test") {
		t.Error("gpg-agent.conf missing correct pinentry-program")
	}
}

func TestWriteConfigs_FilePermissions(t *testing.T) {
	tempDir := t.TempDir()

	gpg := &GPG{
		HomeDir:         tempDir,
		ConfigPath:      filepath.Join(tempDir, "gpg.conf"),
		AgentConfigPath: filepath.Join(tempDir, "gpg-agent.conf"),
		PinentryPath:    "/usr/bin/pinentry",
	}

	err := gpg.writeConfigs()
	if err != nil {
		t.Fatalf("writeConfigs() failed: %v", err)
	}

	gpgConfInfo, err := os.Stat(gpg.ConfigPath)
	if err != nil {
		t.Fatalf("failed to stat gpg.conf: %v", err)
	}

	expectedMode := os.FileMode(0600)
	if gpgConfInfo.Mode().Perm() != expectedMode {
		t.Errorf("gpg.conf permissions: expected %o, got %o", expectedMode, gpgConfInfo.Mode().Perm())
	}

	agentConfInfo, err := os.Stat(gpg.AgentConfigPath)
	if err != nil {
		t.Fatalf("failed to stat gpg-agent.conf: %v", err)
	}

	if agentConfInfo.Mode().Perm() != expectedMode {
		t.Errorf("gpg-agent.conf permissions: expected %o, got %o", expectedMode, agentConfInfo.Mode().Perm())
	}
}

func TestWriteConfigs_InvalidPath(t *testing.T) {
	gpg := &GPG{
		HomeDir:         "/nonexistent/path/that/does/not/exist",
		ConfigPath:      "/nonexistent/path/that/does/not/exist/gpg.conf",
		AgentConfigPath: "/nonexistent/path/that/does/not/exist/gpg-agent.conf",
		PinentryPath:    "/usr/bin/pinentry",
	}

	err := gpg.writeConfigs()
	if err == nil {
		t.Fatal("expected writeConfigs() to fail with invalid path, got nil")
	}
}

func TestGenerateKeys_Success(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234:\n", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", "ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234", "cv25519", "encr", "0"}, "", "", nil)

	gpg := &GPG{
		BinaryPath:   "/usr/bin/gpg",
		HomeDir:      tempDir,
		PinentryPath: "/usr/bin/pinentry",
		executor:     mockExec,
	}

	fingerprint, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err != nil {
		t.Fatalf("GenerateKeys() failed: %v", err)
	}

	expected := "ABCD1234ABCD1234ABCD1234ABCD1234ABCD1234"
	if fingerprint != expected {
		t.Errorf("expected fingerprint %q, got %q", expected, fingerprint)
	}

	if len(mockExec.Calls) != 3 {
		t.Errorf("expected 3 calls, got %d", len(mockExec.Calls))
	}

	if !mockExec.WasCalled("/usr/bin/gpg", "--batch", "--gen-key") {
		t.Error("expected gen-key command to be called")
	}

	if !mockExec.WasCalled("/usr/bin/gpg", "--list-keys", "--with-colons") {
		t.Error("expected list-keys command to be called")
	}
}

func TestGenerateKeys_MasterKeyFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"},
		"", "gpg: error generating key", fmt.Errorf("exit status 2"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
	}

	_, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err == nil {
		t.Fatal("expected GenerateKeys() to fail, got nil")
	}

	if !strings.Contains(err.Error(), "failed to generate master key") {
		t.Errorf("expected error to mention master key generation, got: %v", err)
	}
}

func TestGenerateKeys_SubkeyFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::TESTFINGERPRINT123456789012345678:\n", "", nil)
	mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", "TESTFINGERPRINT123456789012345678", "cv25519", "encr", "0"},
		"", "gpg: error adding subkey", fmt.Errorf("exit status 2"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
	}

	_, err := gpg.GenerateKeys("Test User", "test@example.com")
	if err == nil {
		t.Fatal("expected GenerateKeys() to fail on subkey, got nil")
	}

	if !strings.Contains(err.Error(), "failed to generate encryption subkey") {
		t.Errorf("expected error to mention subkey generation, got: %v", err)
	}
}

func TestGetFingerprint_Success(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"fpr:::::::::FINGERPRINT1234567890ABCDEF1234567890:\n", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
	}

	fingerprint, err := gpg.getFingerprint()
	if err != nil {
		t.Fatalf("getFingerprint() failed: %v", err)
	}

	expected := "FINGERPRINT1234567890ABCDEF1234567890"
	if fingerprint != expected {
		t.Errorf("expected fingerprint %q, got %q", expected, fingerprint)
	}
}

func TestGetFingerprint_ListKeysFails(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"", "gpg: no keys found", fmt.Errorf("exit status 2"))

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
	}

	_, err := gpg.getFingerprint()
	if err == nil {
		t.Fatal("expected getFingerprint() to fail, got nil")
	}

	if !strings.Contains(err.Error(), "failed to list keys") {
		t.Errorf("expected error to mention list keys, got: %v", err)
	}
}

func TestGetFingerprint_NoFingerprintInOutput(t *testing.T) {
	tempDir := t.TempDir()

	mockExec := NewMockExecutor()
	mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
		"pub:u:255:22:1234567890ABCDEF:2025-12-01:::", "", nil)

	gpg := &GPG{
		BinaryPath: "/usr/bin/gpg",
		HomeDir:    tempDir,
		executor:   mockExec,
	}

	_, err := gpg.getFingerprint()
	if err == nil {
		t.Fatal("expected getFingerprint() to fail when no fpr line, got nil")
	}

	if !strings.Contains(err.Error(), "fingerprint not found") {
		t.Errorf("expected error to mention fingerprint not found, got: %v", err)
	}
}

func TestProcessMasterKey_ExportFails(t *testing.T) {
tempDir := t.TempDir()

mockExec := NewMockExecutor()
mockExec.AddResponse("/usr/bin/gpg", []string{"--armor", "--export-secret-key", "TESTFINGERPRINT"},
"", "gpg: key not found", fmt.Errorf("exit status 2"))

gpg := &GPG{
BinaryPath: "/usr/bin/gpg",
HomeDir:    tempDir,
executor:   mockExec,
}

err := gpg.ProcessMasterKey("TESTFINGERPRINT")
if err == nil {
t.Fatal("expected ProcessMasterKey() to fail on export, got nil")
}

if !strings.Contains(err.Error(), "failed to export secret key") {
t.Errorf("expected error to mention export failure, got: %v", err)
}
}

func TestProcessMasterKey_EmptySecretKey(t *testing.T) {
tempDir := t.TempDir()

mockExec := NewMockExecutor()
mockExec.AddResponse("/usr/bin/gpg", []string{"--armor", "--export-secret-key", "TESTFINGERPRINT"},
"", "", nil)

gpg := &GPG{
BinaryPath: "/usr/bin/gpg",
HomeDir:    tempDir,
executor:   mockExec,
}

err := gpg.ProcessMasterKey("TESTFINGERPRINT")
if err == nil {
t.Fatal("expected ProcessMasterKey() to fail with empty key, got nil")
}

if !strings.Contains(err.Error(), "exported secret key is empty") {
t.Errorf("expected error to mention empty secret key, got: %v", err)
}
}

func TestGenerateKeys_FingerprintRetrievalFails(t *testing.T) {
tempDir := t.TempDir()

mockExec := NewMockExecutor()
mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
"", "gpg: no keys", fmt.Errorf("exit status 2"))

gpg := &GPG{
BinaryPath: "/usr/bin/gpg",
HomeDir:    tempDir,
executor:   mockExec,
}

_, err := gpg.GenerateKeys("Test User", "test@example.com")
if err == nil {
t.Fatal("expected GenerateKeys() to fail on fingerprint retrieval, got nil")
}

if !strings.Contains(err.Error(), "failed to list keys") {
t.Errorf("expected error to mention list keys failure, got: %v", err)
}
}

func TestGenerateKeys_WithSpecialCharactersInName(t *testing.T) {
tempDir := t.TempDir()

mockExec := NewMockExecutor()
mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--gen-key"}, "", "", nil)
mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys", "--with-colons"},
"fpr:::::::::SPECIALCHARSFINGERPRINT12345678901234:\n", "", nil)
mockExec.AddResponse("/usr/bin/gpg", []string{"--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", "SPECIALCHARSFINGERPRINT12345678901234", "cv25519", "encr", "0"}, "", "", nil)

gpg := &GPG{
BinaryPath: "/usr/bin/gpg",
HomeDir:    tempDir,
executor:   mockExec,
}

fingerprint, err := gpg.GenerateKeys("Test User (Comment) <tag>", "test+tag@example.com")
if err != nil {
t.Fatalf("GenerateKeys() with special characters failed: %v", err)
}

expected := "SPECIALCHARSFINGERPRINT12345678901234"
if fingerprint != expected {
t.Errorf("expected fingerprint %q, got %q", expected, fingerprint)
}

if len(mockExec.Calls) != 3 {
t.Errorf("expected 3 calls, got %d", len(mockExec.Calls))
}

firstCall := mockExec.Calls[0]
if !strings.Contains(firstCall.Stdin, "Test User (Comment) <tag>") {
t.Error("expected name with special characters in key template")
}
if !strings.Contains(firstCall.Stdin, "test+tag@example.com") {
t.Error("expected email with + character in key template")
}
}

func TestMockExecutor_UnexpectedCommand(t *testing.T) {
mockExec := NewMockExecutor()

_, _, err := mockExec.Execute("/usr/bin/gpg", "--unexpected", "--command")
if err == nil {
t.Fatal("expected mock executor to fail on unexpected command, got nil")
}

if !strings.Contains(err.Error(), "mock: unexpected command") {
t.Errorf("expected error to mention unexpected command, got: %v", err)
}
}

func TestMockExecutor_WasCalled(t *testing.T) {
mockExec := NewMockExecutor()
mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys"}, "output", "", nil)

mockExec.Execute("/usr/bin/gpg", "--list-keys")

if !mockExec.WasCalled("/usr/bin/gpg", "--list-keys") {
t.Error("expected WasCalled to return true for executed command")
}

if mockExec.WasCalled("/usr/bin/gpg", "--other-command") {
t.Error("expected WasCalled to return false for non-executed command")
}
}

func TestMockExecutor_MultipleCallsSameCommand(t *testing.T) {
mockExec := NewMockExecutor()
mockExec.AddResponse("/usr/bin/gpg", []string{"--list-keys"}, "output1", "", nil)

mockExec.Execute("/usr/bin/gpg", "--list-keys")
mockExec.Execute("/usr/bin/gpg", "--list-keys")

if len(mockExec.Calls) != 2 {
t.Errorf("expected 2 calls recorded, got %d", len(mockExec.Calls))
}
}

func TestRealExecutor_SetsGNUPGHOME(t *testing.T) {
tempDir := t.TempDir()

executor := &RealExecutor{HomeDir: tempDir}

_, _, err := executor.Execute("printenv", "GNUPGHOME")
if err != nil {
t.Fatalf("Execute() failed: %v", err)
}
}

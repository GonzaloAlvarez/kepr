/*
Copyright Â© 2025 Gonzalo Alvarez

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package gpg

import (
	"fmt"
	"log/slog"
	"os"
	"path/filepath"
)

func (g *GPG) WriteConfigs() error {
	gpgConf := generateGPGConf()

	slog.Debug("writing gpg.conf", "path", g.ConfigPath)
	if err := os.WriteFile(g.ConfigPath, []byte(gpgConf), 0600); err != nil {
		return fmt.Errorf("failed to write gpg.conf: %w", err)
	}

	agentConf := generateAgentConf(g.PinentryPath)

	slog.Debug("writing gpg-agent.conf", "path", g.AgentConfigPath)
	if err := os.WriteFile(g.AgentConfigPath, []byte(agentConf), 0600); err != nil {
		return fmt.Errorf("failed to write gpg-agent.conf: %w", err)
	}

	scDaemonConf := generateSCDaemonConf()

	slog.Debug("writing scdaemon.conf", "path", g.SCDaemonConfigPath)
	if err := os.WriteFile(g.SCDaemonConfigPath, []byte(scDaemonConf), 0600); err != nil {
		return fmt.Errorf("failed to write scdaemon.conf: %w", err)
	}

	return nil
}

func generateGPGConf() string {
	return `use-agent
no-emit-version
no-comments
keyid-format 0xlong
with-fingerprint
list-options show-uid-validity
verify-options show-uid-validity
`
}

func generateSCDaemonConf() string {
	return `disable-ccid
pcsc-shared
card-timeout 5
`
}

func generateAgentConf(pinentryPath string) string {
	return fmt.Sprintf(`# GPG Agent Config generated by kepr
pinentry-program %s
default-cache-ttl 600
max-cache-ttl 7200
allow-loopback-pinentry
`, pinentryPath)
}

func (g *GPG) replaceSCDaemonConf() error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get user home directory: %w", err)
	}

	gnupgDir := filepath.Join(homeDir, ".gnupg")
	mainSCDaemonPath := filepath.Join(gnupgDir, "scdaemon.conf")
	backupPath := filepath.Join(gnupgDir, "scdaemon.kepr.bak.conf")

	if _, err := os.Stat(backupPath); err == nil {
		slog.Debug("backup already exists, skipping replacement")
		return nil
	}

	if _, err := os.Stat(mainSCDaemonPath); err == nil {
		if err := os.Rename(mainSCDaemonPath, backupPath); err != nil {
			return fmt.Errorf("failed to backup scdaemon.conf: %w", err)
		}
		slog.Debug("backed up scdaemon.conf")
	}

	scDaemonConf := generateSCDaemonConf()
	if err := os.WriteFile(mainSCDaemonPath, []byte(scDaemonConf), 0600); err != nil {
		return fmt.Errorf("failed to write scdaemon.conf: %w", err)
	}

	slog.Debug("replaced scdaemon.conf")
	return nil
}

func (g *GPG) revertSCDaemonConf() error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get user home directory: %w", err)
	}

	gnupgDir := filepath.Join(homeDir, ".gnupg")
	mainSCDaemonPath := filepath.Join(gnupgDir, "scdaemon.conf")
	backupPath := filepath.Join(gnupgDir, "scdaemon.kepr.bak.conf")

	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		slog.Debug("no backup to revert")
		return nil
	}

	if err := os.Remove(mainSCDaemonPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove scdaemon.conf: %w", err)
	}

	if err := os.Rename(backupPath, mainSCDaemonPath); err != nil {
		return fmt.Errorf("failed to restore scdaemon.conf: %w", err)
	}

	slog.Debug("reverted scdaemon.conf")
	return nil
}

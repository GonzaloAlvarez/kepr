/*
Copyright Â© 2025 Gonzalo Alvarez

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package gpg

import (
	"bytes"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/gonzaloalvarez/kepr/pkg/cout"
	"github.com/gonzaloalvarez/kepr/pkg/shell"
)

type GPG struct {
	BinaryPath         string
	PinentryPath       string
	GPGConfPath        string
	HomeDir            string
	AgentConfigPath    string
	ConfigPath         string
	SCDaemonConfigPath string
	executor           shell.Executor
	io                 cout.IO
}

func findPinentry(executor shell.Executor) (string, error) {
	candidates := []string{"pinentry-mac", "pinentry-gnome3", "pinentry", "pinentry-curses"}

	for _, name := range candidates {
		path, err := executor.LookPath(name)
		if err == nil {
			slog.Debug("found pinentry", "program", name, "path", path)
			return path, nil
		}
	}

	return "", fmt.Errorf("no pinentry program found (tried: %v)", candidates)
}

func findGPGConf(executor shell.Executor) string {
	path, err := executor.LookPath("gpgconf")
	if err == nil {
		slog.Debug("found gpgconf", "path", path)
		return path
	}
	slog.Warn("gpgconf not found, some YubiKey operations may fail")
	return ""
}

func New(configBaseDir string, executor shell.Executor, io cout.IO) (*GPG, error) {
	gpgBinary, err := executor.LookPath("gpg")
	if err != nil {
		return nil, fmt.Errorf("gpg binary not found: %w", err)
	}
	slog.Debug("found gpg binary", "path", gpgBinary)

	pinentryBinary, err := findPinentry(executor)
	if err != nil {
		return nil, err
	}

	gpgconfBinary := findGPGConf(executor)

	homeDir := filepath.Join(configBaseDir, "gpg")
	slog.Debug("creating gpg home directory", "path", homeDir)
	if err := os.MkdirAll(homeDir, 0700); err != nil {
		return nil, fmt.Errorf("failed to create gpg home directory: %w", err)
	}

	gpg := &GPG{
		BinaryPath:         gpgBinary,
		PinentryPath:       pinentryBinary,
		GPGConfPath:        gpgconfBinary,
		HomeDir:            homeDir,
		AgentConfigPath:    filepath.Join(homeDir, "gpg-agent.conf"),
		ConfigPath:         filepath.Join(homeDir, "gpg.conf"),
		SCDaemonConfigPath: filepath.Join(homeDir, "scdaemon.conf"),
		executor:           executor,
		io:                 io,
	}

	return gpg, nil
}

func (g *GPG) WriteConfigs() error {
	gpgConf := generateGPGConf()

	slog.Debug("writing gpg.conf", "path", g.ConfigPath)
	if err := os.WriteFile(g.ConfigPath, []byte(gpgConf), 0600); err != nil {
		return fmt.Errorf("failed to write gpg.conf: %w", err)
	}

	agentConf := generateAgentConf(g.PinentryPath)

	slog.Debug("writing gpg-agent.conf", "path", g.AgentConfigPath)
	if err := os.WriteFile(g.AgentConfigPath, []byte(agentConf), 0600); err != nil {
		return fmt.Errorf("failed to write gpg-agent.conf: %w", err)
	}

	scDaemonConf := generateSCDaemonConf()

	slog.Debug("writing scdaemon.conf", "path", g.SCDaemonConfigPath)
	if err := os.WriteFile(g.SCDaemonConfigPath, []byte(scDaemonConf), 0600); err != nil {
		return fmt.Errorf("failed to write scdaemon.conf: %w", err)
	}

	return nil
}

func generateGPGConf() string {
	return `use-agent
no-emit-version
no-comments
keyid-format 0xlong
with-fingerprint
list-options show-uid-validity
verify-options show-uid-validity
`
}

func generateSCDaemonConf() string {
	return `disable-ccid
pcsc-shared
card-timeout 5
`
}

func generateAgentConf(pinentryPath string) string {
	return fmt.Sprintf(`# GPG Agent Config generated by kepr
pinentry-program %s
default-cache-ttl 600
max-cache-ttl 7200
`, pinentryPath)
}

func (g *GPG) execute(stdin string, args ...string) (string, string, error) {
	cmd := g.executor.Command(g.BinaryPath, args...)
	cmd.SetEnv(append(os.Environ(), fmt.Sprintf("GNUPGHOME=%s", g.HomeDir)))

	var stdoutBuf, stderrBuf bytes.Buffer
	cmd.SetStdout(&stdoutBuf)
	cmd.SetStderr(&stderrBuf)

	if stdin != "" {
		cmd.SetStdin(bytes.NewBufferString(stdin))
	}

	err := cmd.Run()
	return stdoutBuf.String(), stderrBuf.String(), err
}

func (g *GPG) executeWithPinentry(stdin string, args ...string) (string, string, error) {
	cmd := g.executor.Command(g.BinaryPath, args...)
	cmd.SetEnv(append(os.Environ(), fmt.Sprintf("GNUPGHOME=%s", g.HomeDir)))

	pr, pw, err := os.Pipe()
	if err != nil {
		return "", "", fmt.Errorf("failed to create pipe: %w", err)
	}
	defer pr.Close()

	tty := cmd.GetEnv("GPG_TTY")
	if tty == "" {
		if out, err := exec.Command("tty").Output(); err == nil {
			tty = strings.TrimSpace(string(out))
		}
	}

	if tty != "" {
		cmd.SetEnv(append(os.Environ(), fmt.Sprintf("GPG_TTY=%s", tty)))
	}

	var stdoutBuf, stderrBuf bytes.Buffer
	cmd.SetStdout(&stdoutBuf)
	cmd.SetStderr(&stderrBuf)

	cmd.SetExtraFiles([]*os.File{pr})
	cmd.SetStdin(os.Stdin)

	err = cmd.Start()
	if err != nil {
		return "", "", fmt.Errorf("failed to start command: %w", err)
	}

	go func() {
		pw.Write([]byte(stdin))
		pw.Close()
	}()

	err = cmd.Wait()
	if err != nil {
		return "", "", fmt.Errorf("failed to wait for command: %w", err)
	}

	return stdoutBuf.String(), stderrBuf.String(), err
}

func (g *GPG) replaceSCDaemonConf() error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get user home directory: %w", err)
	}

	gnupgDir := filepath.Join(homeDir, ".gnupg")
	mainSCDaemonPath := filepath.Join(gnupgDir, "scdaemon.conf")
	backupPath := filepath.Join(gnupgDir, "scdaemon.kepr.bak.conf")

	if _, err := os.Stat(backupPath); err == nil {
		slog.Debug("backup already exists, skipping replacement")
		return nil
	}

	if _, err := os.Stat(mainSCDaemonPath); err == nil {
		if err := os.Rename(mainSCDaemonPath, backupPath); err != nil {
			return fmt.Errorf("failed to backup scdaemon.conf: %w", err)
		}
		slog.Debug("backed up scdaemon.conf")
	}

	scDaemonConf := generateSCDaemonConf()
	if err := os.WriteFile(mainSCDaemonPath, []byte(scDaemonConf), 0600); err != nil {
		return fmt.Errorf("failed to write scdaemon.conf: %w", err)
	}

	slog.Debug("replaced scdaemon.conf")
	return nil
}

func (g *GPG) revertSCDaemonConf() error {
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get user home directory: %w", err)
	}

	gnupgDir := filepath.Join(homeDir, ".gnupg")
	mainSCDaemonPath := filepath.Join(gnupgDir, "scdaemon.conf")
	backupPath := filepath.Join(gnupgDir, "scdaemon.kepr.bak.conf")

	if _, err := os.Stat(backupPath); os.IsNotExist(err) {
		slog.Debug("no backup to revert")
		return nil
	}

	if err := os.Remove(mainSCDaemonPath); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove scdaemon.conf: %w", err)
	}

	if err := os.Rename(backupPath, mainSCDaemonPath); err != nil {
		return fmt.Errorf("failed to restore scdaemon.conf: %w", err)
	}

	slog.Debug("reverted scdaemon.conf")
	return nil
}

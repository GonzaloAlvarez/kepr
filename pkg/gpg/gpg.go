/*
Copyright Â© 2025 Gonzalo Alvarez

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package gpg

import (
	"bytes"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

type GPG struct {
	BinaryPath      string
	PinentryPath    string
	HomeDir         string
	AgentConfigPath string
	ConfigPath      string
}

func findPinentry() (string, error) {
	candidates := []string{"pinentry-mac", "pinentry-gnome3", "pinentry", "pinentry-curses"}

	for _, name := range candidates {
		path, err := exec.LookPath(name)
		if err == nil {
			slog.Debug("found pinentry", "program", name, "path", path)
			return path, nil
		}
	}

	return "", fmt.Errorf("no pinentry program found (tried: %v)", candidates)
}

func New(configBaseDir string) (*GPG, error) {
	gpgBinary, err := exec.LookPath("gpg")
	if err != nil {
		return nil, fmt.Errorf("gpg binary not found: %w", err)
	}
	slog.Debug("found gpg binary", "path", gpgBinary)

	pinentryBinary, err := findPinentry()
	if err != nil {
		return nil, err
	}

	homeDir := filepath.Join(configBaseDir, "gpg")
	slog.Debug("creating gpg home directory", "path", homeDir)
	if err := os.MkdirAll(homeDir, 0700); err != nil {
		return nil, fmt.Errorf("failed to create gpg home directory: %w", err)
	}

	gpg := &GPG{
		BinaryPath:      gpgBinary,
		PinentryPath:    pinentryBinary,
		HomeDir:         homeDir,
		AgentConfigPath: filepath.Join(homeDir, "gpg-agent.conf"),
		ConfigPath:      filepath.Join(homeDir, "gpg.conf"),
	}

	if err := gpg.writeConfigs(); err != nil {
		return nil, err
	}

	return gpg, nil
}

func (g *GPG) writeConfigs() error {
	gpgConf := `use-agent
no-emit-version
no-comments
keyid-format 0xlong
with-fingerprint
list-options show-uid-validity
verify-options show-uid-validity
`

	slog.Debug("writing gpg.conf", "path", g.ConfigPath)
	if err := os.WriteFile(g.ConfigPath, []byte(gpgConf), 0600); err != nil {
		return fmt.Errorf("failed to write gpg.conf: %w", err)
	}

	agentConf := fmt.Sprintf(`# GPG Agent Config generated by kepr
pinentry-program %s
default-cache-ttl 600
max-cache-ttl 7200
`, g.PinentryPath)

	slog.Debug("writing gpg-agent.conf", "path", g.AgentConfigPath)
	if err := os.WriteFile(g.AgentConfigPath, []byte(agentConf), 0600); err != nil {
		return fmt.Errorf("failed to write gpg-agent.conf: %w", err)
	}

	return nil
}

func (g *GPG) GenerateKeys(name, email string) (string, error) {
	slog.Debug("generating master key", "name", name, "email", email)

	keyTemplate := fmt.Sprintf(`Key-Type: EDDSA
Key-Curve: ed25519
Key-Usage: cert
Name-Real: %s
Name-Email: %s
Expire-Date: 0
%%no-protection
%%commit
`, name, email)

	cmd := exec.Command(g.BinaryPath, "--batch", "--gen-key")
	cmd.Env = append(os.Environ(), fmt.Sprintf("GNUPGHOME=%s", g.HomeDir))
	cmd.Stdin = strings.NewReader(keyTemplate)

	var stderr bytes.Buffer
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("failed to generate master key: %w, stderr: %s", err, stderr.String())
	}

	slog.Debug("master key generated, retrieving fingerprint")

	fingerprint, err := g.getFingerprint()
	if err != nil {
		return "", err
	}

	slog.Debug("adding encryption subkey", "fingerprint", fingerprint)

	cmd = exec.Command(g.BinaryPath, "--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", fingerprint, "cv25519", "encr", "0")
	cmd.Env = append(os.Environ(), fmt.Sprintf("GNUPGHOME=%s", g.HomeDir))
	stderr.Reset()
	cmd.Stderr = &stderr

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("failed to generate encryption subkey: %w, stderr: %s", err, stderr.String())
	}

	slog.Debug("encryption subkey generated")
	return fingerprint, nil
}

func (g *GPG) getFingerprint() (string, error) {
	cmd := exec.Command(g.BinaryPath, "--list-keys", "--with-colons")
	cmd.Env = append(os.Environ(), fmt.Sprintf("GNUPGHOME=%s", g.HomeDir))

	var stdout bytes.Buffer
	cmd.Stdout = &stdout

	if err := cmd.Run(); err != nil {
		return "", fmt.Errorf("failed to list keys: %w", err)
	}

	lines := strings.Split(stdout.String(), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "fpr:") {
			fields := strings.Split(line, ":")
			if len(fields) >= 10 {
				fingerprint := fields[9]
				slog.Debug("found fingerprint", "fingerprint", fingerprint)
				return fingerprint, nil
			}
		}
	}

	return "", fmt.Errorf("fingerprint not found in gpg output")
}

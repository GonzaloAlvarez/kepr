/*
Copyright Â© 2025 Gonzalo Alvarez

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/
package gpg

import (
	"bytes"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/gonzaloalvarez/kepr/pkg/cout"
	"github.com/gonzaloalvarez/kepr/pkg/shell"
)

type GPG struct {
	BinaryPath         string
	PinentryPath       string
	HomeDir            string
	AgentConfigPath    string
	ConfigPath         string
	SCDaemonConfigPath string
	executor           shell.Executor
	io                 cout.IO
	Yubikey            *Yubikey
}

func findPinentry(executor shell.Executor) (string, error) {
	candidates := []string{"pinentry-mac", "pinentry-gnome3", "pinentry", "pinentry-curses"}

	for _, name := range candidates {
		path, err := executor.LookPath(name)
		if err == nil {
			slog.Debug("found pinentry", "program", name, "path", path)
			return path, nil
		}
	}

	return "", fmt.Errorf("no pinentry program found (tried: %v)", candidates)
}

func New(configBaseDir string, executor shell.Executor, io cout.IO) (*GPG, error) {
	gpgBinary, err := executor.LookPath("gpg")
	if err != nil {
		return nil, fmt.Errorf("gpg binary not found: %w", err)
	}
	slog.Debug("found gpg binary", "path", gpgBinary)

	pinentryBinary, err := findPinentry(executor)
	if err != nil {
		return nil, err
	}

	homeDir := filepath.Join(configBaseDir, "gpg")
	slog.Debug("creating gpg home directory", "path", homeDir)
	if err := os.MkdirAll(homeDir, 0700); err != nil {
		return nil, fmt.Errorf("failed to create gpg home directory: %w", err)
	}

	gpg := &GPG{
		BinaryPath:         gpgBinary,
		PinentryPath:       pinentryBinary,
		HomeDir:            homeDir,
		AgentConfigPath:    filepath.Join(homeDir, "gpg-agent.conf"),
		ConfigPath:         filepath.Join(homeDir, "gpg.conf"),
		SCDaemonConfigPath: filepath.Join(homeDir, "scdaemon.conf"),
		executor:           executor,
		io:                 io,
	}

	if err := gpg.writeConfigs(); err != nil {
		return nil, err
	}

	return gpg, nil
}

func (g *GPG) writeConfigs() error {
	gpgConf := generateGPGConf()

	slog.Debug("writing gpg.conf", "path", g.ConfigPath)
	if err := os.WriteFile(g.ConfigPath, []byte(gpgConf), 0600); err != nil {
		return fmt.Errorf("failed to write gpg.conf: %w", err)
	}

	agentConf := generateAgentConf(g.PinentryPath)

	slog.Debug("writing gpg-agent.conf", "path", g.AgentConfigPath)
	if err := os.WriteFile(g.AgentConfigPath, []byte(agentConf), 0600); err != nil {
		return fmt.Errorf("failed to write gpg-agent.conf: %w", err)
	}

	scDaemonConf := generateSCDaemonConf()

	slog.Debug("writing scdaemon.conf", "path", g.SCDaemonConfigPath)
	if err := os.WriteFile(g.SCDaemonConfigPath, []byte(scDaemonConf), 0600); err != nil {
		return fmt.Errorf("failed to write scdaemon.conf: %w", err)
	}

	return nil
}

func generateGPGConf() string {
	return `use-agent
no-emit-version
no-comments
keyid-format 0xlong
with-fingerprint
list-options show-uid-validity
verify-options show-uid-validity
`
}

func generateSCDaemonConf() string {
	return `disable-ccid
pcsc-shared
`
}

func generateAgentConf(pinentryPath string) string {
	return fmt.Sprintf(`# GPG Agent Config generated by kepr
pinentry-program %s
default-cache-ttl 600
max-cache-ttl 7200
`, pinentryPath)
}

func (g *GPG) GenerateKeys(name, email string) (string, error) {
	slog.Debug("generating master key", "name", name, "email", email)

	keyTemplate := fmt.Sprintf(`Key-Type: EDDSA
Key-Curve: ed25519
Key-Usage: cert
Name-Real: %s
Name-Email: %s
Expire-Date: 0
%%no-protection
%%commit
`, name, email)

	_, stderr, err := g.execute(keyTemplate, "--batch", "--gen-key")
	if err != nil {
		return "", fmt.Errorf("failed to generate master key: %w, stderr: %s", err, stderr)
	}

	slog.Debug("master key generated, retrieving fingerprint")

	fingerprint, err := g.getFingerprint()
	if err != nil {
		return "", err
	}

	slog.Debug("adding encryption subkey", "fingerprint", fingerprint)

	_, stderr, err = g.execute("", "--batch", "--pinentry-mode", "loopback", "--passphrase", "", "--quick-add-key", fingerprint, "cv25519", "encr", "0")
	if err != nil {
		return "", fmt.Errorf("failed to generate encryption subkey: %w, stderr: %s", err, stderr)
	}

	slog.Debug("encryption subkey generated")
	return fingerprint, nil
}

func (g *GPG) execute(stdin string, args ...string) (string, string, error) {
	cmd := g.executor.Command(g.BinaryPath, args...)
	cmd.SetEnv(append(os.Environ(), fmt.Sprintf("GNUPGHOME=%s", g.HomeDir)))

	var stdoutBuf, stderrBuf bytes.Buffer
	cmd.SetStdout(&stdoutBuf)
	cmd.SetStderr(&stderrBuf)

	if stdin != "" {
		cmd.SetStdin(bytes.NewBufferString(stdin))
	}

	err := cmd.Run()
	return stdoutBuf.String(), stderrBuf.String(), err
}

func (g *GPG) executeWithPinentry(stdin string, args ...string) (string, string, error) {
	cmd := g.executor.Command(g.BinaryPath, args...)
	cmd.SetEnv(append(os.Environ(), fmt.Sprintf("GNUPGHOME=%s", g.HomeDir)))

	pr, pw, err := os.Pipe()
	if err != nil {
		return "", "", fmt.Errorf("failed to create pipe: %w", err)
	}
	defer pr.Close()

	tty := cmd.GetEnv("GPG_TTY")
	if tty == "" {
		if out, err := exec.Command("tty").Output(); err == nil {
			tty = strings.TrimSpace(string(out))
		}
	}

	if tty != "" {
		cmd.SetEnv(append(os.Environ(), fmt.Sprintf("GPG_TTY=%s", tty)))
	}

	var stdoutBuf, stderrBuf bytes.Buffer
	cmd.SetStdout(&stdoutBuf)
	cmd.SetStderr(&stderrBuf)

	cmd.SetExtraFiles([]*os.File{pr})
	cmd.SetStdin(os.Stdin)

	err = cmd.Start()
	if err != nil {
		return "", "", fmt.Errorf("failed to start command: %w", err)
	}

	go func() {
		pw.Write([]byte(stdin))
		pw.Close()
	}()

	err = cmd.Wait()
	if err != nil {
		return "", "", fmt.Errorf("failed to wait for command: %w", err)
	}

	return stdoutBuf.String(), stderrBuf.String(), err
}

func (g *GPG) getFingerprint() (string, error) {
	stdout, _, err := g.execute("", "--list-keys", "--with-colons")
	if err != nil {
		return "", fmt.Errorf("failed to list keys: %w", err)
	}

	return parseFingerprintFromGPGOutput(stdout)
}

func parseFingerprintFromGPGOutput(output string) (string, error) {
	lines := strings.Split(output, "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "fpr:") {
			fields := strings.Split(line, ":")
			if len(fields) >= 10 {
				fingerprint := fields[9]
				slog.Debug("found fingerprint", "fingerprint", fingerprint)
				return fingerprint, nil
			}
		}
	}
	return "", fmt.Errorf("fingerprint not found in gpg output")
}

func (g *GPG) ProcessMasterKey(fingerprint string) error {
	slog.Debug("exporting master key for backup", "fingerprint", fingerprint)

	stdout, stderr, err := g.execute("", "--armor", "--export-secret-key", fingerprint)
	if err != nil {
		return fmt.Errorf("failed to export secret key: %w, stderr: %s", err, stderr)
	}

	secretKey := stdout
	if secretKey == "" {
		return fmt.Errorf("exported secret key is empty")
	}

	g.io.Warning("WARNING: The Master Key below will be DELETED from this machine immediately after this step.")
	g.io.Infoln("")
	g.io.Info(secretKey)
	g.io.Infoln("")
	g.io.Infoln("Copy the key block above and save it to a secure location (e.g., Bitwarden, 1Password, or a Gmail Draft).")

	confirmed, err := g.io.Confirm("Have you saved the Private Key safely? This action cannot be undone.")
	if err != nil {
		return fmt.Errorf("confirmation failed: %w", err)
	}

	if !confirmed {
		return fmt.Errorf("master key backup cancelled by user")
	}

	slog.Debug("user confirmed backup, deleting master key from keyring")

	_, stderr, err = g.execute("", "--batch", "--yes", "--delete-secret-keys", fingerprint)
	if err != nil {
		return fmt.Errorf("failed to delete secret keys: %w, stderr: %s", err, stderr)
	}

	slog.Debug("master key deleted from local keyring")
	g.io.Successln("Master key has been removed from this machine.")

	return nil
}
